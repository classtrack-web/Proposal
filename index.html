<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#0f172a" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>ClassTrack</title>

  <!-- Link the Manifest - Essential for PWA -->
  <link rel="manifest" href="./manifest.json">

  <link rel="icon" type="image/png" href="./logo.png">
  <link rel="apple-touch-icon" href="./logo.png">
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Math Equation CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">

  <script type="module" crossorigin src="/ClassTrack/assets/index-CY-1Lhbb.js"></script>
  <link rel="stylesheet" crossorigin href="/ClassTrack/assets/index-Bx_LPoYQ.css">
</head>

<body>
  <div id="root"></div>
  <!-- Standard module script - Vite will bundle everything automatically -->

  <!-- Service Worker Registration with Full PWA Features -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', async () => {
        try {
          const registration = await navigator.serviceWorker.register('./sw.js');
          console.log('âœ… ClassTrack SW Registered');

          // ========================================
          // 1. Background Sync Registration
          // ========================================
          if ('sync' in registration) {
            try {
              await registration.sync.register('sync-attendance');
              await registration.sync.register('sync-data');
              await registration.sync.register('sync-queue');
              console.log('âœ… Background Sync registered');
            } catch (err) {
              console.warn('âš ï¸ Background Sync not supported:', err);
            }
          }

          // ========================================
          // 2. Periodic Background Sync Registration
          // ========================================
          if ('periodicSync' in registration) {
            try {
              const status = await navigator.permissions.query({ name: 'periodic-background-sync' });
              if (status.state === 'granted') {
                // Register periodic sync tasks
                await registration.periodicSync.register('sync-content', {
                  minInterval: 24 * 60 * 60 * 1000 // 24 hours
                });
                await registration.periodicSync.register('update-data', {
                  minInterval: 12 * 60 * 60 * 1000 // 12 hours
                });
                await registration.periodicSync.register('check-updates', {
                  minInterval: 6 * 60 * 60 * 1000 // 6 hours
                });
                console.log('âœ… Periodic Sync registered');
              } else {
                console.log('âš ï¸ Periodic Sync permission not granted');
              }
            } catch (err) {
              console.warn('âš ï¸ Periodic Sync not supported:', err);
            }
          }

          // ========================================
          // 3. Push Notification Setup
          // ========================================
          if ('pushManager' in registration) {
            try {
              // Check if already subscribed
              const subscription = await registration.pushManager.getSubscription();
              if (!subscription) {
                console.log('ðŸ“¢ Push notifications available - user can enable in settings');
              } else {
                console.log('âœ… Push notifications already enabled');
              }
            } catch (err) {
              console.warn('âš ï¸ Push Notifications not supported:', err);
            }
          }

          // ========================================
          // 4. Listen for SW Messages
          // ========================================
          navigator.serviceWorker.addEventListener('message', (event) => {
            console.log('ðŸ“¨ SW Message:', event.data);
            if (event.data.type === 'SYNC_COMPLETE') {
              console.log('âœ… Background sync completed');
              window.dispatchEvent(new CustomEvent('pwa-sync-complete'));
            } else if (event.data.type === 'PERIODIC_SYNC_COMPLETE') {
              console.log('âœ… Periodic sync completed');
              window.dispatchEvent(new CustomEvent('pwa-periodic-sync-complete'));
            } else if (event.data.type === 'REFRESH_DATA') {
              window.dispatchEvent(new CustomEvent('pwa-refresh-data'));
            } else if (event.data.type === 'NOTIFICATION_CLICK') {
              window.dispatchEvent(new CustomEvent('pwa-notification-click', { detail: event.data }));
            }
          });

          // ========================================
          // 5. Handle SW Updates
          // ========================================
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                console.log('ðŸ”„ New SW version available');
                window.dispatchEvent(new CustomEvent('pwa-update-available'));
              }
            });
          });

        } catch (err) {
          console.error('âŒ SW Registration Failed:', err);
        }
      });

      // Online/Offline status handling
      window.addEventListener('online', () => {
        console.log('ðŸŒ Online - triggering sync');
        navigator.serviceWorker.ready.then((registration) => {
          if ('sync' in registration) {
            registration.sync.register('sync-queue');
          }
        });
      });

      window.addEventListener('offline', () => {
        console.log('ðŸ“´ Offline - requests will be queued');
      });
    }

    // Helper function to request push notification permission
    window.requestPushPermission = async function () {
      if (!('Notification' in window)) {
        console.warn('Push notifications not supported');
        return false;
      }

      const permission = await Notification.requestPermission();
      if (permission === 'granted') {
        console.log('âœ… Push notification permission granted');
        const registration = await navigator.serviceWorker.ready;
        try {
          const subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: null // Add your VAPID public key here for production
          });
          console.log('Push subscription:', subscription.toJSON());
          return true;
        } catch (err) {
          console.error('Push subscription failed:', err);
          return false;
        }
      }
      return false;
    };

    // Helper function to queue requests for background sync
    window.queueForSync = async function (requestData) {
      const registration = await navigator.serviceWorker.ready;
      if (registration.active) {
        return new Promise((resolve) => {
          const messageChannel = new MessageChannel();
          messageChannel.port1.onmessage = (event) => resolve(event.data);
          registration.active.postMessage(
            { type: 'QUEUE_REQUEST', request: requestData },
            [messageChannel.port2]
          );
        });
      }
    };
  </script>
</body>

</html>